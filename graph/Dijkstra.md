# Dijkstra算法详解

Dijkstra算法是由荷兰计算机科学家艾兹赫尔·戴克斯特拉（Edsger W. Dijkstra）在1956年提出的一种用于解决**单源最短路径问题**的经典算法。它能够找到图中从一个起始节点到所有其他节点的最短路径。

## 算法基本思想

Dijkstra算法的核心思想是**贪心算法**，它通过逐步扩展已知的最短路径集合来工作：

1. 维护一个集合S，包含已经找到最短路径的节点
2. 每次从集合外的节点中选择距离起始节点最近的节点加入S
3. 更新新加入节点的所有邻居的距离
4. 重复上述过程直到所有节点都在S中

## 算法步骤详解

### 初始化
1. 为每个节点v分配一个距离值：
   - 起始节点的距离初始化为0
   - 其他所有节点的距离初始化为∞
2. 所有节点初始状态为"未访问"
3. 创建一个优先队列（最小堆），包含所有节点

### 主循环
1. 从优先队列中取出距离最小的节点u（即当前距离起始节点最近的未访问节点）
2. 将u标记为"已访问"
3. 对于u的每一个邻居v：
   - 计算从起始节点经过u到v的路径长度：`alt = dist[u] + weight(u, v)`
   - 如果`alt < dist[v]`，则：
     - 更新`dist[v] = alt`
     - 记录v的前驱节点为u
     - 调整优先队列以反映距离变化

### 终止条件
当优先队列为空（所有节点都已访问）时，算法结束

## 算法伪代码

```
function Dijkstra(Graph, source):
    dist[source] ← 0
    for each vertex v in Graph:
        if v ≠ source
            dist[v] ← ∞
            prev[v] ← undefined
        add v to Q

    while Q is not empty:
        u ← vertex in Q with min dist[u]
        remove u from Q

        for each neighbor v of u:
            alt ← dist[u] + length(u, v)
            if alt < dist[v]:
                dist[v] ← alt
                prev[v] ← u
                decrease-key v in Q
    return dist[], prev[]
```

## 复杂度分析

- **时间复杂度**：
  - 使用数组实现优先队列：O(V²)
  - 使用二叉堆实现优先队列：O((V+E) log V)
  - 使用斐波那契堆实现优先队列：O(E + V log V)

- **空间复杂度**：O(V)（用于存储距离和前驱信息）

## 算法特性

1. **适用范围**：
   - 有向图或无向图
   - 边权重必须为非负值（这是Dijkstra算法的关键限制）

2. **正确性证明**：
   - 基于贪心选择性质和最优子结构
   - 每次选择的局部最优解最终导致全局最优解

3. **局限性**：
   - 不能处理负权边（会破坏贪心选择性质）
   - 对于大规模稀疏图可能效率不高

## 实际应用

Dijkstra算法广泛应用于：
- 网络路由协议（如OSPF）
- 交通导航系统
- 社交网络中的最短路径分析
- 机器人路径规划
- 电信网络设计

## 示例

考虑以下有向图：
```
节点: A (起点), B, C, D, E
边:
A→B: 6
A→D: 1
D→B: 2
D→E: 1
B→C: 5
E→B: 2
E→C: 5
```

执行Dijkstra算法的步骤：
1. 初始距离：A(0), B(∞), C(∞), D(∞), E(∞)
2. 访问D(距离1)，更新B(3), E(2)
3. 访问E(距离2)，更新B(3), C(7)
4. 访问B(距离3)，更新C(8)
5. 访问C(距离7)
6. 算法结束

最终最短路径：
A→B: 3 (A-D-B)
A→C: 7 (A-D-E-C)
A→D: 1
A→E: 2 (A-D-E)

## 实现注意事项

1. 优先队列的实现方式显著影响性能
2. 对于大规模图，可以考虑使用A*算法等优化变种
3. 在实际应用中，可能需要记录完整路径而不仅仅是距离
4. 对于特定场景（如网格图），可能有更高效的专用算法

Dijkstra算法因其简单性和有效性，成为图论中最重要和最常用的算法之一。
